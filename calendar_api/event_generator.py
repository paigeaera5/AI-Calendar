"""
Create event based on LLM response and user preferences.

This is what connects to the front end for generating llm events.
"""

import os, sys
from typing import List
from enum import IntEnum
from datetime import datetime, timedelta
from event_service import EventsService
from availability import Availability
from event import Event
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from llm.task import Task


class Days(IntEnum):
    """Enum class for assigning int values to days of the week."""

    M = 0   # Monday
    T = 1   # Tuesday
    W = 2   # Wednesday
    R = 3   # Thursday
    F = 4   # Friday
    S = 5   # Saturday
    U = 6   # Sunday


class EventGenerator(EventsService):
    """Class for creating events based on llm output."""

    def __init__(
            self,
            task_obj: Task,
            subtasks: List,
            descriptions: List
    ) -> None:
        """
        Initialize generator.

        :param event_name:  User specified event name
        :param llm_output:  Output generated by llm
        :param start_date:  Start date of larger task
        :param start_time:  Start time of daily time frame
        :param end_date:    End date of larger task
        :param end_time:    End time of daily time frame
        :param days:        List of user specified days of the week
        """
        super().__init__()
        self.task = task_obj
        self.subtasks = subtasks
        self.task_lengths = self._find_task_lengths(subtasks=subtasks)
        self.desciptions = descriptions

        start_date = datetime.strptime(task_obj.start_date,
                                       "%a, %d %b %Y %H:%M:%S %z").date()
        end_date = datetime.strptime(task_obj.end_date,
                                     "%a, %d %b %Y %H:%M:%S %z").date()

        start_time = datetime.strptime(task_obj.start_time,
                                       "%a, %d %b %Y %H:%M:%S %z").time()
        end_time = datetime.strptime(task_obj.end_time,
                                     "%a, %d %b %Y %H:%M:%S %z").time()

        days = []
        for day in task_obj.days:
            days.append(Days[day.upper()])

        self.available = Availability(
            start_date=start_date,
            start_time=start_time,
            end_date=end_date,
            end_time=end_time,
            days=days
        )
        self.generated_events = self._make_events(event_name=task_obj.name)

    def add_to_cal(self) -> None:
        """Add all generated events to the users calendar."""
        for event in self.generated_events:
            self.add_event(event)

    def _find_task_lengths(
            self,
            subtasks: List
    ) -> List:
        lengths = []
        for task in subtasks:
            time_idx = task.find('(time:') + 6
            time_end = task.find(')', time_idx)
            num, interval = task[time_idx:time_end].strip().split()
            num = int(num)
            lengths.append((num, interval))
        return lengths

    def _find_time_matches(
            self,
            lengths: List,
    ) -> List:
        """Find corresponding available times for subtasks."""
        time_list = []
        frees = self.available.frees
        day_idx = self.available.free_days
        next_free = 0
        for num, interval in lengths:
            found = False
            while not found:
                if next_free >= len(day_idx):
                    # Return empty list if not enough time available
                    return []
                times = frees.get(day_idx[next_free])
                for cur in times:
                    time_diff = cur[1] - cur[0]
                    if 'hour' in interval:
                        total = time_diff.total_seconds() / 3600
                    elif 'minute' in interval:
                        total = time_diff.total_seconds() / 60

                    if total < num:
                        continue

                    found = True
                    time_list.append(cur)
                    break
                next_free += 1
        return time_list

    def _make_events(
            self,
            event_name: str
    ) -> List:
        """Create Event objects for each subtask."""
        events = []
        subtasks = self.subtasks
        task_lengths = self.task_lengths
        times = self._find_time_matches(lengths=task_lengths)

        error_msg = """Not enough free time found. \
Either make daily time frame longer or add more days of the week.\
"""

        assert (len(times) == len(self.subtasks)), error_msg

        for i, task in enumerate(self.subtasks):
            event_summary = event_name.capitalize()+' (Part ' + str(i+1) + ')'
            description = task + '\n\n' + self.desciptions[i]
            num, interval = task_lengths[i]

            start = times[i][0]
            if 'hour' in interval:
                end = start + timedelta(hours=num)
            elif 'minute' in interval:
                end = start + timedelta(minutes=num)

            timezone = self.default_cal['timeZone']
            events.append(
                Event(
                    summary=event_summary,
                    start=start,
                    end=end,
                    timezone=timezone,
                    description=task + ':\n\n' + self.desciptions[i]
                )
            )
        return events
